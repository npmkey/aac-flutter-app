import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:audioplayers/audioplayers.dart';
import 'dart:convert';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'AAC App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        fontFamily: 'Sans-serif',
      ),
      home: const AACScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class AACScreen extends StatefulWidget {
  const AACScreen({super.key});

  @override
  State<AACScreen> createState() => _AACScreenState();
}

class _AACScreenState extends State<AACScreen> {
  // --- ESTADO DA APLICAÇÃO ---
  final List<String> _componentWords = ['Eu', 'amo', 'você', 'quero', 'água'];
  final List<Map<String, dynamic>> _sentenceWords = [];
  int _nextWordId = 0; // Para dar um ID único a cada palavra na frase

  bool _isReading = false;
  final AudioPlayer _audioPlayer = AudioPlayer();

  // --- FUNÇÕES DE LÓGICA ---

  // Gera a string da frase e chama a API para ler
  void _readSentence() async {
    if (_sentenceWords.isEmpty || _isReading) return;

    setState(() {
      _isReading = true;
    });

    String textToRead = _sentenceWords.map((word) => word['text']).join(' ');
    print('Frase formada: $textToRead');

    try {
      // --- CHAMADA À API ELEVENLABS ---
      const apiKey = '45b8752851121ffaf84736d8b21240d8c273de6c8f964cf1a39076078872b767'; // <-- COLOQUE SUA CHAVE AQUI
      const voiceId = 'GhkQkxbimoIykF4iGYqh'; // <-- COLOQUE O ID DA VOZ AQUI

      final url = Uri.parse('https://api.elevenlabs.io/v1/text-to-speech/$voiceId');
      final headers = {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': apiKey,
      };
      final body = json.encode({
        'text': textToRead,
        'model_id': 'eleven_multilingual_v2',
        'voice_settings': {
          'stability': 0.5,
          'similarity_boost': 0.75,
        },
      });

      final response = await http.post(url, headers: headers, body: body);

      if (response.statusCode == 200) {
        await _audioPlayer.play(BytesSource(response.bodyBytes));
      } else {
        print('Erro na API: ${response.body}');
        _showErrorDialog('Erro ao gerar o áudio.');
      }
    } catch (e) {
      print('Erro de conexão: $e');
      _showErrorDialog('Erro de conexão ao tentar ler a frase.');
    } finally {
      setState(() {
        _isReading = false;
      });
    }
  }

  void _showErrorDialog(String message) {
    if (!mounted) return;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Ocorreu um Erro'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('Ok'),
            onPressed: () => Navigator.of(ctx).pop(),
          ),
        ],
      ),
    );
  }

  // --- CONSTRUÇÃO DA INTERFACE (WIDGETS) ---
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('AAC App'),
        backgroundColor: Colors.white,
        elevation: 1,
      ),
      backgroundColor: Colors.grey[100],
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // 1. Caixa de Texto (Frase + Botão Ler)
            _buildSentenceBox(),
            const SizedBox(height: 30),

            // 2. Caixa de Componentes
            Expanded(
              child: _buildComponentBox(),
            ),
            const SizedBox(height: 20),

            // 3. Lixeira
            _buildTrashArea(),
          ],
        ),
      ),
    );
  }

  // A caixa superior que contém a frase e o botão de play
  Widget _buildSentenceBox() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFdfefff),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          // Área onde as palavras da frase são soltas
          Expanded(
            child: DragTarget<Map<String, dynamic>>(
              builder: (context, candidateData, rejectedData) {
                return Container(
                  height: 60,
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: candidateData.isNotEmpty ? Colors.blue.withOpacity(0.1) : Colors.white,
                    borderRadius: BorderRadius.circular(5),
                    border: Border.all(color: Colors.grey.shade400),
                  ),
                  child: _sentenceWords.isEmpty
                      ? const Center(child: Text('Arraste aqui', style: TextStyle(color: Colors.grey)))
                      : ReorderableListView(
                          scrollDirection: Axis.horizontal,
                          children: _sentenceWords.map((word) => _buildDraggableWord(word, isFromSentence: true)).toList(),
                          onReorder: (oldIndex, newIndex) {
                            setState(() { 
                              if (newIndex > oldIndex) {
                                newIndex -= 1;
                              }
                              final item = _sentenceWords.removeAt(oldIndex);
                              _sentenceWords.insert(newIndex, item);
                            });
                          },
                        ),
                );
              },
              onWillAcceptWithDetails: (data) => true,
              onAcceptWithDetails: (details) {
                setState(() {
                  // Se a palavra vem dos componentes, adiciona um novo ID
                  if (details.data['isClone']) {
                    _sentenceWords.add({'id': _nextWordId++, 'text': details.data['text'], 'isClone': false});
                  }
                });
              },
            ),
          ),
          const SizedBox(width: 10),
          // Botão para ler a frase
          ElevatedButton(
            onPressed: _readSentence,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue,
              foregroundColor: Colors.white,
              shape: const CircleBorder(),
              padding: const EdgeInsets.all(15),
            ),
            child: _isReading
                ? const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3))
                : const Icon(Icons.play_arrow, size: 30),
          ),
        ],
      ),
    );
  }

  // A caixa do meio com as palavras disponíveis para arrastar
  Widget _buildComponentBox() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.shade300),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Wrap(
        spacing: 10,
        runSpacing: 10,
        children: _componentWords.map((word) => _buildDraggableWord({'text': word, 'isClone': true}, isFromSentence: false)).toList(),
      ),
    );
  }

  // A lixeira na parte inferior
  Widget _buildTrashArea() {
    return DragTarget<Map<String, dynamic>>(
      builder: (context, candidateData, rejectedData) {
        bool isHovering = candidateData.isNotEmpty;
        return Container(
          height: 80,
          width: double.infinity,
          decoration: BoxDecoration(
            color: isHovering ? Colors.red.withOpacity(0.2) : Colors.transparent,
            border: Border.all(color: isHovering ? Colors.red : Colors.grey.shade400, width: 2),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Icon(
              isHovering ? Icons.delete_forever : Icons.delete_outline,
              color: isHovering ? Colors.red : Colors.grey.shade600,
              size: 40,
            ),
          ),
        );
      },
      onWillAcceptWithDetails: (details) => details.data != null && !details.data['isClone'], // Só aceita palavras que já estão na frase
      onAcceptWithDetails: (details) {
        setState(() {
          _sentenceWords.removeWhere((word) => word['id'] == details.data['id']);
        });
      },
    );
  }

  // Widget que representa uma única palavra arrastável
  Widget _buildDraggableWord(Map<String, dynamic> wordData, {required bool isFromSentence}) {
    Widget wordBlock = Container(
      // key: ValueKey(wordData['id'] ?? wordData['text']), //Removido daqui
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(5),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 3, offset: const Offset(0, 1))],
      ),
      child: Text(wordData['text'], style: const TextStyle(fontSize: 16)),
    );

    return Draggable<Map<String, dynamic>>(
      key: ValueKey(wordData['id'] ?? wordData['text']), //Adicionado aqui
      data: wordData,
      feedback: Material(
        elevation: 4.0,
        color: Colors.transparent,
        child: wordBlock,
      ),
      childWhenDragging: isFromSentence ? const SizedBox.shrink() : wordBlock, // O original some da frase ao arrastar
      child: wordBlock,
    );
  }
}
