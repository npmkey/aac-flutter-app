import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:audioplayers/audioplayers.dart';
import 'dart:convert';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'AAC App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        fontFamily: 'Sans-serif',
      ),
      home: const AACScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class AACScreen extends StatefulWidget {
  const AACScreen({super.key});

  @override
  State<AACScreen> createState() => _AACScreenState();
}

class _AACScreenState extends State<AACScreen> {
  // --- ESTADO DA APLICAÇÃO ---
  // Agora, cada palavra é um componente com texto e uma imagem associada.
  final List<Map<String, dynamic>> _componentWords = [
    {'text': 'Eu,', 'image': 'assets/images/eu.png'},
    {'text': 'amo,', 'image': 'assets/images/amo.png'},
    {'text': 'você,', 'image': 'assets/images/voce.png'},
    {'text': 'nao,', 'image': 'assets/images/eu.png'},
    {'text': 'sim,', 'image': 'assets/images/amo.png'},
    {'text': 'quero,', 'image': 'assets/images/voce.png'},
  ];
  final List<Map<String, dynamic>> _sentenceWords = [];
  int _nextWordId = 0; // Para dar um ID único a cada palavra na frase

  bool _isReading = false;
  final AudioPlayer _audioPlayer = AudioPlayer();

  // --- FUNÇÕES DE LÓGICA ---

  // Gera a string da frase e chama a API para ler
  void _readSentence() async {
    if (_sentenceWords.isEmpty || _isReading) return;

    setState(() {
      _isReading = true;
    });

    String textToRead = _sentenceWords.map((word) => word['text']).join(' ');
    print('Frase formada: $textToRead');

    try {
      // --- CHAMADA À API ELEVENLABS ---
      const apiKey = '45b8752851121ffaf84736d8b21240d8c273de6c8f964cf1a39076078872b767'; // <-- COLOQUE SUA CHAVE AQUI
      const voiceId = 'GhkQkxbimoIykF4iGYqh'; // <-- COLOQUE O ID DA VOZ AQUI

      final url = Uri.parse('https://api.elevenlabs.io/v1/text-to-speech/$voiceId');
      final headers = {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': apiKey,
      };
      final body = json.encode({
        'text': textToRead,
        'model_id': 'eleven_multilingual_v2',
        'voice_settings': {
          'stability': 0.5,
          'similarity_boost': 0.75,
        },
      });

      final response = await http.post(url, headers: headers, body: body);

      if (response.statusCode == 200) {
        await _audioPlayer.play(BytesSource(response.bodyBytes));
      } else {
        print('Erro na API: ${response.body}');
        _showErrorDialog('Erro ao gerar o áudio.');
      }
    } catch (e) {
      print('Erro de conexão: $e');
      _showErrorDialog('Erro de conexão ao tentar ler a frase.');
    } finally {
      setState(() {
        _isReading = false;
      });
    }
  }

  void _showErrorDialog(String message) {
    if (!mounted) return;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Ocorreu um Erro'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('Ok'),
            onPressed: () => Navigator.of(ctx).pop(),
          ),
        ],
      ),
    );
  }

  // --- CONSTRUÇÃO DA INTERFACE (WIDGETS) ---
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('AAC App'),
        backgroundColor: Colors.white,
        elevation: 1,
      ),
      backgroundColor: Colors.grey[100],
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // 1. Caixa de Texto (Frase + Botão Ler)
            _buildSentenceBox(),
            const SizedBox(height: 30),

            // 2. Caixa de Componentes
            Expanded(
              child: _buildComponentBox(),
            ),
            const SizedBox(height: 20),

            // 3. Lixeira
            _buildTrashArea(),
          ],
        ),
      ),
    );
  }

  // A caixa superior que contém a frase e o botão de play
  Widget _buildSentenceBox() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFdfefff),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          // Área onde as palavras da frase são soltas
          Expanded(
            child: DragTarget<Map<String, dynamic>>(
              builder: (context, candidateData, rejectedData) {
                return Container(
                  height: 137,
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: candidateData.isNotEmpty ? Colors.blue.withOpacity(0.1) : Colors.white,
                    borderRadius: BorderRadius.circular(5),
                    border: Border.all(color: Colors.grey.shade400),
                  ),
                  child: _sentenceWords.isEmpty
                      ? const Center(child: Text('Arraste aqui', style: TextStyle(color: Colors.grey)))
                      : ReorderableListView(
                          buildDefaultDragHandles: false,
                          scrollDirection: Axis.horizontal,
                          children: _sentenceWords.map((word) => _buildDraggableWord(word, isFromSentence: true)).toList(),
                          onReorder: (oldIndex, newIndex) {
                            setState(() { 
                              if (newIndex > oldIndex) {
                                newIndex -= 1;
                              }
                              final item = _sentenceWords.removeAt(oldIndex);
                              _sentenceWords.insert(newIndex, item);
                            });
                          },
                        ),
                );
              },
              onWillAcceptWithDetails: (data) => true,
              onAcceptWithDetails: (details) {
                setState(() {
                  // Se a palavra vem dos componentes, adiciona um novo ID
                  if (details.data['isClone']) {
                    _sentenceWords.add({
                      'id': _nextWordId++,
                      'text': details.data['text'],
                      'image': details.data['image'], // Também passamos a imagem
                      'isClone': false
                    });
                  }
                });
              },
            ),
          ),
          const SizedBox(width: 10),
          // Botão para ler a frase
          ElevatedButton(
            onPressed: _readSentence,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue,
              foregroundColor: Colors.white,
              shape: const CircleBorder(),
              padding: const EdgeInsets.all(15),
            ),
            child: _isReading
                ? const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3))
                : const Icon(Icons.play_arrow, size: 30),
          ),
        ],
      ),
    );
  }

  // A caixa do meio com as palavras disponíveis para arrastar
  Widget _buildComponentBox() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.shade300),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Wrap(
        spacing: 10,
        runSpacing: 10,
        // Mapeamos a nova lista de componentes, adicionando 'isClone'
        children: _componentWords.map((componentData) {
          final data = Map<String, dynamic>.from(componentData);
          data['isClone'] = true;
          return _buildDraggableWord(data, isFromSentence: false);
        }).toList(),
      ),
    );
  }

  // A lixeira na parte inferior
  Widget _buildTrashArea() {
    return DragTarget<Map<String, dynamic>>(
      builder: (context, candidateData, rejectedData) {
        bool isHovering = candidateData.isNotEmpty;
        return Container(
          height: 80,
          width: double.infinity,
          decoration: BoxDecoration(
            color: isHovering ? Colors.red.withOpacity(0.2) : Colors.transparent,
            border: Border.all(color: isHovering ? Colors.red : Colors.grey.shade400, width: 2),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Icon(
              isHovering ? Icons.delete_forever : Icons.delete_outline,
              color: isHovering ? Colors.red : Colors.grey.shade600,
              size: 40,
            ),
          ),
        );
      },
      onWillAcceptWithDetails: (details) => details.data != null && !details.data['isClone'], // Só aceita palavras que já estão na frase
      onAcceptWithDetails: (details) {
        setState(() {
          _sentenceWords.removeWhere((word) => word['id'] == details.data['id']);
        });
      },
    );
  }

  // Widget que representa uma única palavra arrastável
  Widget _buildDraggableWord(Map<String, dynamic> wordData, {required bool isFromSentence}) {
    Widget wordBlock = Stack(
      alignment: Alignment.center,
      children: [
        Container(
          width: 90, // Largura fixa para melhor alinhamento
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(5),
            boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 3, offset: const Offset(0, 1))],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Exibe a imagem. Use um placeholder se a imagem não for encontrada.
              Image.asset(wordData['image'], width: 60, height: 60, fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) {
                return const Icon(Icons.image_not_supported, size: 60, color: Colors.grey);
              }),
              const SizedBox(height: 8),
              Text(wordData['text'], style: const TextStyle(fontSize: 16)),
              if (isFromSentence) const SizedBox(height: 12), // Espaço extra para o puxador
            ],
          ),
        ),
        // Adiciona um puxador customizado apenas para os itens na frase
        if (isFromSentence)
          Positioned(
            bottom: 2,
            child: ReorderableDragStartListener(
              index: _sentenceWords.indexWhere((w) => w['id'] == wordData['id']),
              child: const Icon(Icons.drag_handle, color: Colors.grey, size: 20),
            ),
          ),
      ],
    );

    // O Draggable agora envolve o Stack
    return Draggable<Map<String, dynamic>>(
      key: ValueKey(wordData['id'] ?? wordData['text']), // Chave única para todos os casos
      data: wordData,
      feedback: Material(
        elevation: 4.0,
        color: Colors.transparent,
        child: wordBlock,
      ),
      childWhenDragging: isFromSentence ? const SizedBox.shrink() : wordBlock, // O original some da frase ao arrastar
      child: wordBlock,
    );
  }
}
